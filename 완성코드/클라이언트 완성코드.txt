#include <stdio.h>
#include <string.h>
#include <winsock.h>
#include <process.h>
#pragma comment(lib,"wsock32.lib")
#define PORT 5000			// 사용할 포트는 5000
#define IP "127.0.0.1"// 접속할 서버는 로컬 호스트
void recv_thread(void*);	// 스레드 수행 함수의 프로토 타입
int state=1;
int ret = 0;				// 리턴 값
int s = 0;					// 소켓 값

HANDLE hMutex;				// 뮤텍스용

int main()
{
	char log[5][10]={"kkk/kkk","ddd/ddd","jsik/jsjs","nhj/nhnh","kjh/kjkj"};//회원들의 정보
	while(state)//로그인에 대한 부분
	{
		char get[10];//입력받을 정보저장 변수
		printf("id와 pw를 /를 이용해 구분하여 입력해주세요\n");
		scanf("%s",get);
		fflush(stdin);
		for(int i=0;i<5;i++)//입력정보와 회원정보를 비교하기 위한 함수
		{
			if(strcmp(get,log[i])==0)//같을경우
			{
				state=0;//루프 빠져나온 후 연결
			}
		}
		if(state!=0)
		{
			printf("틀렸습니다. 다시입력하세요.\n");
		}
	}

	// 뮤택스 초기화
	hMutex = CreateMutex(NULL, FALSE, FALSE);
	if(!hMutex)
	{
		printf("Mutex 생성 오류\n");
		return 1;
	}

	// 윈속 초기화
	WSADATA wsd;
	char buff[1024];
	if(WSAStartup(MAKEWORD(1,1), &wsd) != 0)
	{
		printf("Winsock 오류\n");
		return 1;
	}

	// 서버로 접속하기 위한 소켓 생성
	sockaddr_in server;

	s = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
	if (s == SOCKET_ERROR)
	{
		printf("socket() 오류\n");
		closesocket(s);
		WSACleanup();
		return 1;

	}

	server.sin_addr.s_addr = inet_addr(IP);
	server.sin_family = AF_INET;
	server.sin_port = htons(PORT);

	// 서버와 연결
	if( connect(s, (sockaddr*)&server, sizeof(server)) == SOCKET_ERROR)
	{
		printf("connect() 오류\n");
		closesocket(s);
		WSACleanup();
		return 1;

	}

	printf("서버와 연결이 되었음.\n");

	// 서버에서 우선 주는 Welcome 메시지 분석
	ret = recv(s, buff, 1024,0);
	printf("%s", buff);

	// 가득 찼다고 메시지가 왔다면
	if(!strcmp("가득찼습니다.\n",buff))
	{
		closesocket(s);
		WSACleanup();
		return 0;			// 접속을 종료
	}

	// 정상 접속이 되면 스레드 작동 - 받는 메시지를 스레드로 실시간 수행
	_beginthread(recv_thread, 0, NULL);

	// 보내는 메시지는 스레드로 넣을 필요가 없습니다.
	while(ret != INVALID_SOCKET || ret != SOCKET_ERROR)
	{
	
		// 딜레이 : CPU 점유율 감소용
		Sleep(10);
		fgets(buff, 1024, stdin);
		
		// 전송 결과 잘못 된 결과를 얻었을때 탈출
		if(ret == INVALID_SOCKET || ret == SOCKET_ERROR) break;

		// 서버로 보내는 글은 fgets 을 받고 나서 순차적으로 보냄
		ret = send(s, buff, strlen(buff), 0);

		// 버퍼 초기화
		memset(buff, 0, 1024);

	}
	
	// 정상/비정상으로 서버와 통신 결과값이 틀린 값을 받았을 때
	printf("서버와 연결이 끊겼습니다.\n");
	closesocket(s);
	WSACleanup();

	return 0;
}

// 받는 스레드 부분
void recv_thread(void* pData)
{
		
		int ret_thread = 65535;
		char buff_thread[1024] = {0};
		
		// 스레드용 리턴 값이 원하는 값이 아니면 받는 중에 서버와 통신이 끊겼다고 보고 나감
		while(ret_thread != INVALID_SOCKET || ret_thread != SOCKET_ERROR)
		{	
			while(state)
			{
				Sleep(10);	// CPU 점유률 100% 방지용

				// 서버에서 주는 메시지를 실시간으로 기다렸다가 받습니다.
				ret_thread = recv(s, buff_thread, sizeof(buff_thread), 0);

				// 서버에서 받는 작업을 한 결과 비정상일 때 탈출
				if(ret_thread == INVALID_SOCKET || ret_thread == SOCKET_ERROR)
					break;
			
				// 정상적으로 받은 버퍼를 출력
				printf("승인결과: %s",buff_thread);
				if(*buff_thread=='Y')
				{
					state=0;
				}
				memset(buff_thread,0,1024);	// 받은 버퍼를 초기와
			}
			Sleep(10);	// CPU 점유률 100% 방지용

			// 서버에서 주는 메시지를 실시간으로 기다렸다가 받습니다.
			ret_thread = recv(s, buff_thread, sizeof(buff_thread), 0);

			// 서버에서 받는 작업을 한 결과 비정상일 때 탈출
			if(ret_thread == INVALID_SOCKET || ret_thread == SOCKET_ERROR)
				break;
			
			// 정상적으로 받은 버퍼를 출력
			printf("상대: %s",buff_thread);
			memset(buff_thread,0,1024);	// 받은 버퍼를 초기와
		}

		// 작업이 끝난 소켓을 무효화시킴
		WaitForSingleObject(hMutex,100L);
		ret = INVALID_SOCKET;
		ReleaseMutex(hMutex);
		return;
}